/**\n * Comprehensive Internationalization Service\n * \n * Provides full multi-language support with dynamic loading,\n * regional preferences, and cultural adaptations\n */\n\nimport { v4 as uuidv4 } from 'uuid';\n\nexport interface Language {\n  code: string;\n  name: string;\n  nativeName: string;\n  region: string;\n  direction: 'ltr' | 'rtl';\n  dateFormat: string;\n  numberFormat: {\n    decimal: string;\n    thousands: string;\n    currency: string;\n  };\n  isComplete: boolean;\n  lastUpdated: string;\n}\n\nexport interface TranslationKey {\n  key: string;\n  context?: string;\n  pluralForms?: string[];\n  variables?: Record<string, string>;\n}\n\nexport interface TranslationEntry {\n  [key: string]: string | TranslationEntry | string[];\n}\n\nexport interface LocalizationPreferences {\n  language: string;\n  region: string;\n  timeZone: string;\n  dateFormat: 'short' | 'medium' | 'long' | 'full';\n  timeFormat: '12h' | '24h';\n  numberFormat: 'decimal' | 'scientific' | 'engineering';\n  currency: string;\n  unitSystem: 'metric' | 'imperial';\n}\n\nclass InternationalizationService {\n  private translations: Map<string, TranslationEntry> = new Map();\n  private currentLanguage: string = 'en';\n  private fallbackLanguage: string = 'en';\n  private loadedLanguages: Set<string> = new Set();\n  private localizationPreferences: LocalizationPreferences;\n  \n  // Event callbacks\n  private onLanguageChangeCallback?: (language: string) => void;\n  private onTranslationLoadCallback?: (language: string, success: boolean) => void;\n\n  constructor() {\n    this.initializeDefaultLanguages();\n    this.loadUserPreferences();\n  }\n\n  /**\n   * Initialize internationalization service\n   */\n  async initialize(): Promise<void> {\n    try {\n      // Load default language translations\n      await this.loadLanguageTranslations(this.currentLanguage);\n      \n      // Load fallback language if different\n      if (this.fallbackLanguage !== this.currentLanguage) {\n        await this.loadLanguageTranslations(this.fallbackLanguage);\n      }\n      \n      // Apply localization settings\n      this.applyLocalizationSettings();\n      \n      console.log('üåç Internationalization service initialized');\n    } catch (error) {\n      console.error('‚ùå Failed to initialize internationalization service:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get available languages\n   */\n  getAvailableLanguages(): Language[] {\n    return [\n      {\n        code: 'en',\n        name: 'English',\n        nativeName: 'English',\n        region: 'US',\n        direction: 'ltr',\n        dateFormat: 'MM/dd/yyyy',\n        numberFormat: { decimal: '.', thousands: ',', currency: '$' },\n        isComplete: true,\n        lastUpdated: '2024-01-15',\n      },\n      {\n        code: 'es',\n        name: 'Spanish',\n        nativeName: 'Espa√±ol',\n        region: 'ES',\n        direction: 'ltr',\n        dateFormat: 'dd/MM/yyyy',\n        numberFormat: { decimal: ',', thousands: '.', currency: '‚Ç¨' },\n        isComplete: true,\n        lastUpdated: '2024-01-15',\n      },\n      {\n        code: 'fr',\n        name: 'French',\n        nativeName: 'Fran√ßais',\n        region: 'FR',\n        direction: 'ltr',\n        dateFormat: 'dd/MM/yyyy',\n        numberFormat: { decimal: ',', thousands: ' ', currency: '‚Ç¨' },\n        isComplete: true,\n        lastUpdated: '2024-01-15',\n      },\n      {\n        code: 'de',\n        name: 'German',\n        nativeName: 'Deutsch',\n        region: 'DE',\n        direction: 'ltr',\n        dateFormat: 'dd.MM.yyyy',\n        numberFormat: { decimal: ',', thousands: '.', currency: '‚Ç¨' },\n        isComplete: true,\n        lastUpdated: '2024-01-15',\n      },\n      {\n        code: 'it',\n        name: 'Italian',\n        nativeName: 'Italiano',\n        region: 'IT',\n        direction: 'ltr',\n        dateFormat: 'dd/MM/yyyy',\n        numberFormat: { decimal: ',', thousands: '.', currency: '‚Ç¨' },\n        isComplete: true,\n        lastUpdated: '2024-01-15',\n      },\n      {\n        code: 'pt',\n        name: 'Portuguese',\n        nativeName: 'Portugu√™s',\n        region: 'BR',\n        direction: 'ltr',\n        dateFormat: 'dd/MM/yyyy',\n        numberFormat: { decimal: ',', thousands: '.', currency: 'R$' },\n        isComplete: true,\n        lastUpdated: '2024-01-15',\n      },\n      {\n        code: 'ja',\n        name: 'Japanese',\n        nativeName: 'Êó•Êú¨Ë™û',\n        region: 'JP',\n        direction: 'ltr',\n        dateFormat: 'yyyy/MM/dd',\n        numberFormat: { decimal: '.', thousands: ',', currency: '¬•' },\n        isComplete: false,\n        lastUpdated: '2024-01-10',\n      },\n      {\n        code: 'ko',\n        name: 'Korean',\n        nativeName: 'ÌïúÍµ≠Ïñ¥',\n        region: 'KR',\n        direction: 'ltr',\n        dateFormat: 'yyyy.MM.dd',\n        numberFormat: { decimal: '.', thousands: ',', currency: '‚Ç©' },\n        isComplete: false,\n        lastUpdated: '2024-01-10',\n      },\n      {\n        code: 'zh',\n        name: 'Chinese (Simplified)',\n        nativeName: 'ÁÆÄ‰Ωì‰∏≠Êñá',\n        region: 'CN',\n        direction: 'ltr',\n        dateFormat: 'yyyy/MM/dd',\n        numberFormat: { decimal: '.', thousands: ',', currency: '¬•' },\n        isComplete: false,\n        lastUpdated: '2024-01-10',\n      },\n      {\n        code: 'ar',\n        name: 'Arabic',\n        nativeName: 'ÿßŸÑÿπÿ±ÿ®Ÿäÿ©',\n        region: 'SA',\n        direction: 'rtl',\n        dateFormat: 'dd/MM/yyyy',\n        numberFormat: { decimal: 'Ÿ´', thousands: 'Ÿ¨', currency: 'ÿ±.ÿ≥' },\n        isComplete: false,\n        lastUpdated: '2024-01-05',\n      },\n      {\n        code: 'ru',\n        name: 'Russian',\n        nativeName: '–†—É—Å—Å–∫–∏–π',\n        region: 'RU',\n        direction: 'ltr',\n        dateFormat: 'dd.MM.yyyy',\n        numberFormat: { decimal: ',', thousands: ' ', currency: '‚ÇΩ' },\n        isComplete: false,\n        lastUpdated: '2024-01-08',\n      },\n      {\n        code: 'hi',\n        name: 'Hindi',\n        nativeName: '‡§π‡§ø‡§®‡•ç‡§¶‡•Ä',\n        region: 'IN',\n        direction: 'ltr',\n        dateFormat: 'dd/MM/yyyy',\n        numberFormat: { decimal: '.', thousands: ',', currency: '‚Çπ' },\n        isComplete: false,\n        lastUpdated: '2024-01-05',\n      },\n    ];\n  }\n\n  /**\n   * Change current language\n   */\n  async changeLanguage(languageCode: string): Promise<void> {\n    try {\n      // Validate language code\n      const availableLanguages = this.getAvailableLanguages();\n      const language = availableLanguages.find(lang => lang.code === languageCode);\n      \n      if (!language) {\n        throw new Error(`Unsupported language code: ${languageCode}`);\n      }\n      \n      // Load translations if not already loaded\n      if (!this.loadedLanguages.has(languageCode)) {\n        await this.loadLanguageTranslations(languageCode);\n      }\n      \n      this.currentLanguage = languageCode;\n      \n      // Update localization preferences\n      this.localizationPreferences.language = languageCode;\n      this.localizationPreferences.region = language.region;\n      \n      // Apply new localization settings\n      this.applyLocalizationSettings();\n      \n      // Save preferences\n      this.saveUserPreferences();\n      \n      // Notify listeners\n      if (this.onLanguageChangeCallback) {\n        this.onLanguageChangeCallback(languageCode);\n      }\n      \n      console.log(`üåç Language changed to: ${language.name}`);\n    } catch (error) {\n      console.error('‚ùå Failed to change language:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Translate a key with optional variables and pluralization\n   */\n  translate(key: string, variables?: Record<string, string | number>, count?: number): string {\n    const translation = this.getTranslation(key, this.currentLanguage) || \n                       this.getTranslation(key, this.fallbackLanguage) ||\n                       key; // Return key if no translation found\n    \n    // Handle pluralization\n    if (count !== undefined && Array.isArray(translation)) {\n      const pluralForm = this.getPluralForm(count, this.currentLanguage);\n      const pluralTranslation = translation[pluralForm] || translation[0] || key;\n      return this.interpolateVariables(pluralTranslation, { ...variables, count });\n    }\n    \n    // Handle string translation\n    if (typeof translation === 'string') {\n      return this.interpolateVariables(translation, variables);\n    }\n    \n    return key;\n  }\n\n  /**\n   * Translate with context\n   */\n  translateWithContext(key: string, context: string, variables?: Record<string, string | number>): string {\n    const contextKey = `${context}.${key}`;\n    return this.translate(contextKey, variables);\n  }\n\n  /**\n   * Format date according to current locale\n   */\n  formatDate(date: Date, format?: 'short' | 'medium' | 'long' | 'full'): string {\n    const formatType = format || this.localizationPreferences.dateFormat;\n    \n    const options: Intl.DateTimeFormatOptions = {\n      short: { dateStyle: 'short' },\n      medium: { dateStyle: 'medium' },\n      long: { dateStyle: 'long' },\n      full: { dateStyle: 'full' },\n    }[formatType] || { dateStyle: 'medium' };\n    \n    return new Intl.DateTimeFormat(\n      `${this.currentLanguage}-${this.localizationPreferences.region}`,\n      options\n    ).format(date);\n  }\n\n  /**\n   * Format time according to current locale\n   */\n  formatTime(date: Date): string {\n    const hour12 = this.localizationPreferences.timeFormat === '12h';\n    \n    return new Intl.DateTimeFormat(\n      `${this.currentLanguage}-${this.localizationPreferences.region}`,\n      {\n        timeStyle: 'short',\n        hour12,\n      }\n    ).format(date);\n  }\n\n  /**\n   * Format number according to current locale\n   */\n  formatNumber(number: number, options?: Intl.NumberFormatOptions): string {\n    return new Intl.NumberFormat(\n      `${this.currentLanguage}-${this.localizationPreferences.region}`,\n      options\n    ).format(number);\n  }\n\n  /**\n   * Format currency according to current locale\n   */\n  formatCurrency(amount: number, currency?: string): string {\n    const currencyCode = currency || this.localizationPreferences.currency;\n    \n    return new Intl.NumberFormat(\n      `${this.currentLanguage}-${this.localizationPreferences.region}`,\n      {\n        style: 'currency',\n        currency: currencyCode,\n      }\n    ).format(amount);\n  }\n\n  /**\n   * Get current language info\n   */\n  getCurrentLanguage(): Language {\n    const languages = this.getAvailableLanguages();\n    return languages.find(lang => lang.code === this.currentLanguage) || languages[0];\n  }\n\n  /**\n   * Get localization preferences\n   */\n  getLocalizationPreferences(): LocalizationPreferences {\n    return { ...this.localizationPreferences };\n  }\n\n  /**\n   * Update localization preferences\n   */\n  updateLocalizationPreferences(preferences: Partial<LocalizationPreferences>): void {\n    this.localizationPreferences = {\n      ...this.localizationPreferences,\n      ...preferences,\n    };\n    \n    this.applyLocalizationSettings();\n    this.saveUserPreferences();\n  }\n\n  /**\n   * Get translation completion status\n   */\n  getTranslationStatus(languageCode: string): { complete: number; total: number; percentage: number } {\n    const baseTranslations = this.translations.get(this.fallbackLanguage);\n    const targetTranslations = this.translations.get(languageCode);\n    \n    if (!baseTranslations || !targetTranslations) {\n      return { complete: 0, total: 0, percentage: 0 };\n    }\n    \n    const totalKeys = this.countTranslationKeys(baseTranslations);\n    const completeKeys = this.countCompleteKeys(baseTranslations, targetTranslations);\n    const percentage = totalKeys > 0 ? Math.round((completeKeys / totalKeys) * 100) : 0;\n    \n    return { complete: completeKeys, total: totalKeys, percentage };\n  }\n\n  /**\n   * Export translations for external translation services\n   */\n  exportTranslations(languageCode: string, format: 'json' | 'csv' | 'po' = 'json'): string {\n    const translations = this.translations.get(languageCode);\n    \n    if (!translations) {\n      throw new Error(`No translations found for language: ${languageCode}`);\n    }\n    \n    switch (format) {\n      case 'json':\n        return JSON.stringify(translations, null, 2);\n      \n      case 'csv':\n        return this.exportToCSV(translations);\n      \n      case 'po':\n        return this.exportToPO(translations, languageCode);\n      \n      default:\n        throw new Error(`Unsupported export format: ${format}`);\n    }\n  }\n\n  /**\n   * Import translations from external sources\n   */\n  async importTranslations(languageCode: string, data: string, format: 'json' | 'csv' | 'po' = 'json'): Promise<void> {\n    try {\n      let translations: TranslationEntry;\n      \n      switch (format) {\n        case 'json':\n          translations = JSON.parse(data);\n          break;\n        \n        case 'csv':\n          translations = this.importFromCSV(data);\n          break;\n        \n        case 'po':\n          translations = this.importFromPO(data);\n          break;\n        \n        default:\n          throw new Error(`Unsupported import format: ${format}`);\n      }\n      \n      this.translations.set(languageCode, translations);\n      this.loadedLanguages.add(languageCode);\n      \n      console.log(`üì• Imported translations for ${languageCode}`);\n    } catch (error) {\n      console.error(`‚ùå Failed to import translations for ${languageCode}:`, error);\n      throw error;\n    }\n  }\n\n  // Event listeners\n  onLanguageChange(callback: (language: string) => void): void {\n    this.onLanguageChangeCallback = callback;\n  }\n\n  onTranslationLoad(callback: (language: string, success: boolean) => void): void {\n    this.onTranslationLoadCallback = callback;\n  }\n\n  // Private methods\n\n  private initializeDefaultLanguages(): void {\n    this.currentLanguage = this.detectUserLanguage();\n    this.fallbackLanguage = 'en';\n    \n    // Initialize with basic English translations\n    this.translations.set('en', this.getDefaultEnglishTranslations());\n    this.loadedLanguages.add('en');\n  }\n\n  private detectUserLanguage(): string {\n    // Try to detect user's preferred language\n    const browserLanguage = navigator.language.split('-')[0];\n    const supportedLanguages = this.getAvailableLanguages().map(lang => lang.code);\n    \n    return supportedLanguages.includes(browserLanguage) ? browserLanguage : 'en';\n  }\n\n  private loadUserPreferences(): void {\n    try {\n      const saved = localStorage.getItem('astral_turf_i18n_preferences');\n      if (saved) {\n        const preferences = JSON.parse(saved);\n        this.localizationPreferences = {\n          language: preferences.language || this.currentLanguage,\n          region: preferences.region || 'US',\n          timeZone: preferences.timeZone || Intl.DateTimeFormat().resolvedOptions().timeZone,\n          dateFormat: preferences.dateFormat || 'medium',\n          timeFormat: preferences.timeFormat || '24h',\n          numberFormat: preferences.numberFormat || 'decimal',\n          currency: preferences.currency || 'USD',\n          unitSystem: preferences.unitSystem || 'metric',\n        };\n        this.currentLanguage = this.localizationPreferences.language;\n      } else {\n        this.localizationPreferences = {\n          language: this.currentLanguage,\n          region: 'US',\n          timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n          dateFormat: 'medium',\n          timeFormat: '24h',\n          numberFormat: 'decimal',\n          currency: 'USD',\n          unitSystem: 'metric',\n        };\n      }\n    } catch (error) {\n      console.error('Failed to load user preferences:', error);\n      this.localizationPreferences = {\n        language: this.currentLanguage,\n        region: 'US',\n        timeZone: 'UTC',\n        dateFormat: 'medium',\n        timeFormat: '24h',\n        numberFormat: 'decimal',\n        currency: 'USD',\n        unitSystem: 'metric',\n      };\n    }\n  }\n\n  private saveUserPreferences(): void {\n    try {\n      localStorage.setItem(\n        'astral_turf_i18n_preferences',\n        JSON.stringify(this.localizationPreferences)\n      );\n    } catch (error) {\n      console.error('Failed to save user preferences:', error);\n    }\n  }\n\n  private applyLocalizationSettings(): void {\n    // Apply text direction\n    const currentLang = this.getCurrentLanguage();\n    document.documentElement.dir = currentLang.direction;\n    document.documentElement.lang = this.currentLanguage;\n    \n    // Update CSS custom properties for RTL support\n    if (currentLang.direction === 'rtl') {\n      document.body.classList.add('rtl');\n    } else {\n      document.body.classList.remove('rtl');\n    }\n  }\n\n  private async loadLanguageTranslations(languageCode: string): Promise<void> {\n    try {\n      // In a real application, this would load from a server or bundle\n      // For now, we'll use mock translations\n      const translations = this.getMockTranslations(languageCode);\n      \n      this.translations.set(languageCode, translations);\n      this.loadedLanguages.add(languageCode);\n      \n      if (this.onTranslationLoadCallback) {\n        this.onTranslationLoadCallback(languageCode, true);\n      }\n      \n      console.log(`üìö Loaded translations for ${languageCode}`);\n    } catch (error) {\n      console.error(`‚ùå Failed to load translations for ${languageCode}:`, error);\n      \n      if (this.onTranslationLoadCallback) {\n        this.onTranslationLoadCallback(languageCode, false);\n      }\n      \n      throw error;\n    }\n  }\n\n  private getTranslation(key: string, languageCode: string): string | string[] | undefined {\n    const translations = this.translations.get(languageCode);\n    if (!translations) return undefined;\n    \n    const keys = key.split('.');\n    let current: any = translations;\n    \n    for (const k of keys) {\n      if (current && typeof current === 'object' && k in current) {\n        current = current[k];\n      } else {\n        return undefined;\n      }\n    }\n    \n    return current;\n  }\n\n  private interpolateVariables(text: string, variables?: Record<string, string | number>): string {\n    if (!variables) return text;\n    \n    return text.replace(/\\{\\{(\\w+)\\}\\}/g, (match, key) => {\n      const value = variables[key];\n      return value !== undefined ? String(value) : match;\n    });\n  }\n\n  private getPluralForm(count: number, languageCode: string): number {\n    // Simplified plural rules - in a real implementation, use Intl.PluralRules\n    switch (languageCode) {\n      case 'en':\n      case 'de':\n      case 'it':\n      case 'es':\n      case 'pt':\n        return count === 1 ? 0 : 1;\n      \n      case 'fr':\n        return count <= 1 ? 0 : 1;\n      \n      case 'ru':\n        const mod10 = count % 10;\n        const mod100 = count % 100;\n        if (mod10 === 1 && mod100 !== 11) return 0;\n        if (mod10 >= 2 && mod10 <= 4 && (mod100 < 10 || mod100 >= 20)) return 1;\n        return 2;\n      \n      default:\n        return count === 1 ? 0 : 1;\n    }\n  }\n\n  private countTranslationKeys(obj: TranslationEntry, prefix = ''): number {\n    let count = 0;\n    \n    for (const [key, value] of Object.entries(obj)) {\n      const fullKey = prefix ? `${prefix}.${key}` : key;\n      \n      if (typeof value === 'string' || Array.isArray(value)) {\n        count++;\n      } else if (typeof value === 'object') {\n        count += this.countTranslationKeys(value, fullKey);\n      }\n    }\n    \n    return count;\n  }\n\n  private countCompleteKeys(base: TranslationEntry, target: TranslationEntry, prefix = ''): number {\n    let count = 0;\n    \n    for (const [key, value] of Object.entries(base)) {\n      const fullKey = prefix ? `${prefix}.${key}` : key;\n      \n      if (typeof value === 'string' || Array.isArray(value)) {\n        if (target[key] && typeof target[key] === typeof value) {\n          count++;\n        }\n      } else if (typeof value === 'object' && target[key] && typeof target[key] === 'object') {\n        count += this.countCompleteKeys(value, target[key] as TranslationEntry, fullKey);\n      }\n    }\n    \n    return count;\n  }\n\n  private exportToCSV(translations: TranslationEntry): string {\n    const rows: string[] = ['Key,Translation'];\n    \n    const flatten = (obj: TranslationEntry, prefix = '') => {\n      for (const [key, value] of Object.entries(obj)) {\n        const fullKey = prefix ? `${prefix}.${key}` : key;\n        \n        if (typeof value === 'string') {\n          rows.push(`\"${fullKey}\",\"${value.replace(/\"/g, '\"\"')}\"`); // Escape quotes\n        } else if (Array.isArray(value)) {\n          value.forEach((item, index) => {\n            rows.push(`\"${fullKey}[${index}]\",\"${item.replace(/\"/g, '\"\"')}\"`); // Escape quotes\n          });\n        } else if (typeof value === 'object') {\n          flatten(value, fullKey);\n        }\n      }\n    };\n    \n    flatten(translations);\n    return rows.join('\\n');\n  }\n\n  private exportToPO(translations: TranslationEntry, languageCode: string): string {\n    let po = `# Astral Turf Translations - ${languageCode}\\n`;\n    po += `# Generated on ${new Date().toISOString()}\\n`;\n    po += `msgid \"\"\\n`;\n    po += `msgstr \"\"\\n`;\n    po += `\"Language: ${languageCode}\\\\n\"\\n\\n`;\n    \n    const flatten = (obj: TranslationEntry, prefix = '') => {\n      for (const [key, value] of Object.entries(obj)) {\n        const fullKey = prefix ? `${prefix}.${key}` : key;\n        \n        if (typeof value === 'string') {\n          po += `msgid \"${fullKey}\"\\n`;\n          po += `msgstr \"${value.replace(/\"/g, '\\\\\"')}\"\\n\\n`; // Escape quotes\n        } else if (typeof value === 'object' && !Array.isArray(value)) {\n          flatten(value, fullKey);\n        }\n      }\n    };\n    \n    flatten(translations);\n    return po;\n  }\n\n  private importFromCSV(data: string): TranslationEntry {\n    const lines = data.split('\\n');\n    const translations: TranslationEntry = {};\n    \n    for (let i = 1; i < lines.length; i++) {\n      const line = lines[i].trim();\n      if (!line) continue;\n      \n      const match = line.match(/^\"([^\"]*)\",\"([^\"]*)\"$/);\n      if (match) {\n        const [, key, value] = match;\n        this.setNestedValue(translations, key, value);\n      }\n    }\n    \n    return translations;\n  }\n\n  private importFromPO(data: string): TranslationEntry {\n    const translations: TranslationEntry = {};\n    const entries = data.split('\\n\\n');\n    \n    for (const entry of entries) {\n      const lines = entry.trim().split('\\n');\n      let msgid = '';\n      let msgstr = '';\n      \n      for (const line of lines) {\n        if (line.startsWith('msgid ')) {\n          msgid = line.substring(7, line.length - 1); // Remove msgid \" and \"\n        } else if (line.startsWith('msgstr ')) {\n          msgstr = line.substring(8, line.length - 1); // Remove msgstr \" and \"\n        }\n      }\n      \n      if (msgid && msgstr) {\n        this.setNestedValue(translations, msgid, msgstr);\n      }\n    }\n    \n    return translations;\n  }\n\n  private setNestedValue(obj: TranslationEntry, key: string, value: string): void {\n    const keys = key.split('.');\n    let current = obj;\n    \n    for (let i = 0; i < keys.length - 1; i++) {\n      const k = keys[i];\n      if (!(k in current) || typeof current[k] !== 'object') {\n        current[k] = {};\n      }\n      current = current[k] as TranslationEntry;\n    }\n    \n    current[keys[keys.length - 1]] = value;\n  }\n\n  private getDefaultEnglishTranslations(): TranslationEntry {\n    return {\n      common: {\n        save: 'Save',\n        cancel: 'Cancel',\n        delete: 'Delete',\n        edit: 'Edit',\n        add: 'Add',\n        remove: 'Remove',\n        confirm: 'Confirm',\n        yes: 'Yes',\n        no: 'No',\n        ok: 'OK',\n        loading: 'Loading...',\n        error: 'Error',\n        success: 'Success',\n        warning: 'Warning',\n        info: 'Information',\n      },\n      navigation: {\n        tactics: 'Tactics',\n        players: 'Players',\n        training: 'Training',\n        matches: 'Matches',\n        finances: 'Finances',\n        stadium: 'Stadium',\n        analytics: 'Analytics',\n        settings: 'Settings',\n      },\n      tactics: {\n        formation: 'Formation',\n        instructions: 'Instructions',\n        lineup: 'Lineup',\n        substitutions: 'Substitutions',\n        save_formation: 'Save Formation',\n        load_formation: 'Load Formation',\n      },\n      players: {\n        name: 'Name',\n        age: 'Age',\n        position: 'Position',\n        rating: 'Rating',\n        potential: 'Potential',\n        stamina: 'Stamina',\n        morale: 'Morale',\n        form: 'Form',\n        injury_status: 'Injury Status',\n      },\n      matches: {\n        upcoming: 'Upcoming Matches',\n        results: 'Results',\n        fixtures: 'Fixtures',\n        simulate: 'Simulate',\n        tactics_board: 'Tactics Board',\n      },\n      settings: {\n        language: 'Language',\n        region: 'Region',\n        timezone: 'Time Zone',\n        date_format: 'Date Format',\n        time_format: 'Time Format',\n        currency: 'Currency',\n        unit_system: 'Unit System',\n      },\n    };\n  }\n\n  private getMockTranslations(languageCode: string): TranslationEntry {\n    // Mock translations for demonstration\n    // In a real application, these would be loaded from translation files\n    const translations: Record<string, TranslationEntry> = {\n      es: {\n        common: {\n          save: 'Guardar',\n          cancel: 'Cancelar',\n          delete: 'Eliminar',\n          edit: 'Editar',\n          add: 'A√±adir',\n          remove: 'Quitar',\n          loading: 'Cargando...',\n        },\n        navigation: {\n          tactics: 'T√°cticas',\n          players: 'Jugadores',\n          training: 'Entrenamiento',\n          matches: 'Partidos',\n          finances: 'Finanzas',\n          stadium: 'Estadio',\n          analytics: 'Anal√≠ticas',\n          settings: 'Configuraci√≥n',\n        },\n      },\n      fr: {\n        common: {\n          save: 'Enregistrer',\n          cancel: 'Annuler',\n          delete: 'Supprimer',\n          edit: 'Modifier',\n          add: 'Ajouter',\n          remove: 'Retirer',\n          loading: 'Chargement...',\n        },\n        navigation: {\n          tactics: 'Tactiques',\n          players: 'Joueurs',\n          training: 'Entra√Ænement',\n          matches: 'Matchs',\n          finances: 'Finances',\n          stadium: 'Stade',\n          analytics: 'Analyses',\n          settings: 'Param√®tres',\n        },\n      },\n      de: {\n        common: {\n          save: 'Speichern',\n          cancel: 'Abbrechen',\n          delete: 'L√∂schen',\n          edit: 'Bearbeiten',\n          add: 'Hinzuf√ºgen',\n          remove: 'Entfernen',\n          loading: 'Laden...',\n        },\n        navigation: {\n          tactics: 'Taktiken',\n          players: 'Spieler',\n          training: 'Training',\n          matches: 'Spiele',\n          finances: 'Finanzen',\n          stadium: 'Stadion',\n          analytics: 'Analysen',\n          settings: 'Einstellungen',\n        },\n      },\n    };\n\n    return translations[languageCode] || this.getDefaultEnglishTranslations();\n  }\n}\n\n// Singleton instance\nexport const i18nService = new InternationalizationService();